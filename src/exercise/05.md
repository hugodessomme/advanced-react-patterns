# State Reducer

## üìù Your Notes

J'ai appris comment donner plus de flexibilit√© aux utilisateurs de custom hooks
en leur laissant la possibilit√© de surcharger le reducer utilis√© au sein du
custom hook. Pour cela, il suffit d'accepter un param√®tre `reducer` √†
l'ex√©cution du cutsom hook qui surchargera le reducer par d√©faut.

```js
// use-toggle.js
function toggleReducer(state, action) {
  switch (action.type) {
    case 'toggle':
      return {on: !state.on}
    case 'reset':
      return {on: false}
    default:
      throw new Error(`Unhandled type: ${action.type}`)
  }
}

// On accepte un param√®tre reducer avec comme d√©faut celui d√©finit par le custom hook
function useToggle(reducer = toggleReducer) {
  const [state, dispatch] = React.useReducer(reducer)
  const {on} = state
  const toggle = () => dispatch('toggle')
  const reset = () => dispatch('toggle')

  return {on, toggle, reset}
}

export {useToggle}

// App.js
import {useToggle} from './use-toggle'
function App() {
  // On d√©finit notre propre reducer
  function customReducer(state, action) {
    switch (action.type) {
      case 'toggle':
        // Your custom logic
        return {}
      case 'reset':
        return {on: false}
    }
  }

  const {on, toggle, reset} = useToggle(customReducer) // <-- on passe notre propre reducer
}
```

Le probl√®me avec cette approche est que lorsque l'utilisateur voudra surcharger
le reducer par d√©faut, il devra r√©-impl√©menter toute la logique du reducer
initial, m√™me s'il n'a pas besoin de le modifier (dans l'exemple ci-dessus,
`customReducer` doit r√©√©crire la logique du `reset` m√™me s'il ne modifie pas ce
comportement). On pr√©f√©rera alors fournir √† l'utilisateur le reducer par d√©faut
qu'il pourra modifier au besoin, ou utiliser tel quel le cas √©ch√©ant.

```js
// use-toggle.js
export {useToggle, toggleReducer} // <-- On exporte le reducer par d√©faut

// App.js
import {useToggle, toggleReducer} from './use-toggle'

function App() {
  function customReducer(state, action) {
    // On surcharge la section du reducer n√©cessaire
    if (action.type === 'toggle' && yourOwnLogic) {
      return {on: state.on}
    }

    // Sinon, on utilise le reducer par d√©faut
    return toggleReducer(state, action)
  }
}
```

Enfin, plut√¥t que d'√©crire en dur chaque type d'action du reducer (c√¥t√© custom
hook et c√¥t√© utilisateur), on fournira plut√¥t un objet listant les actions
disponibles, permettant d'√©viter les typos et aider √† l'auto-compl√©tion.

```js
// use-toggle.js
// On liste les actions disponibles au sein du reducer
const actionTypes = {
  toggle: 'toggle',
  reset: 'reset',
}

function toggleReducer(state, action) {
  switch (action.type) {
    // Gr√¢ce √† cet objet, on √©vite les typos c√¥t√© custom hook [1/2]
    case actionTypes.toggle:
    // ...
  }
}

export {useToggle, actionTypes, toggleReducer} // <-- On exporte la liste d'actions

// App.js
import {useToggle, toggleReducer, actionTypes} from './use-toggle'

function App() {
  function customReducer() {
    // On √©vite aussi les typos c√¥t√© utilisateur et on peut profiter de l'auto-compl√©tion [2/2]
    if (actionTypes.toggle && yourCustomLogic) {
      return {on: state.on}
    }

    return toggleReducer(state, action)
  }
}
```

## Background

**One liner:** The State Reducer Pattern inverts control over the state
management of your hook and/or component to the developer using it so they can
control the state changes that happen when dispatching events.

During the life of a reusable component which is used in many different
contexts, feature requests are made over and over again to handle different
cases and cater to different scenarios.

We could definitely add props to our component and add logic in our reducer for
how to handle these different cases, but there's a never ending list of logical
customizations that people could want out of our custom hook and we don't want
to have to code for every one of those cases.

üìú Read more about this pattern in:
[The State Reducer Pattern with React Hooks](https://kentcdodds.com/blog/the-state-reducer-pattern-with-react-hooks)

**Real World Projects that use this pattern:**

- [downshift](https://github.com/downshift-js/downshift)

## Exercise

Production deploys:

- [Exercise](http://advanced-react-patterns.netlify.app/isolated/exercise/05.js)
- [Final](http://advanced-react-patterns.netlify.app/isolated/final/05.js)

In this exercise, we want to prevent the toggle from updating the toggle state
after it's been clicked 4 times in a row before resetting. We could easily add
that logic to our reducer, but instead we're going to apply a computer science
pattern called "Inversion of Control" where we effectively say: "Here you go!
You have complete control over how this thing works. It's now your
responsibility."

> As an aside, before React Hooks were a thing, this was pretty tricky to
> implement and resulted in pretty weird code, but with useReducer, this is WAY
> better. I ‚ù§Ô∏è hooks. üòç

Your job is to enable people to provide a custom `reducer` so they can have
complete control over how state updates happen in our `<Toggle />` component.

## Extra Credit

### 1. üíØ default state reducer

[Production deploy](http://advanced-react-patterns.netlify.app/isolated/final/05.extra-1.js)

Our `toggleReducer` is pretty simple, so it's not a huge pain for people to
implement their own. However, in a more realistic scenario, people may struggle
with having to basically re-implement our entire reducer which could be pretty
complex. So see if you can provide a nice way for people to be able to use the
`toggleReducer` themselves if they so choose. Feel free to test this out by
changing the `toggleStateReducer` function inside the `<App />` example to use
the default reducer instead of having to re-implement what to do when the action
type is `'reset'`:

```javascript
function toggleStateReducer(state, action) {
  if (action.type === 'toggle' && timesClicked >= 4) {
    return {on: state.on}
  }
  return toggleReducer(state, action)
}
```

### 2. üíØ state reducer action types

[Production deploy](http://advanced-react-patterns.netlify.app/isolated/final/05.extra-2.js)

Requiring people to know what action types are available and code them is just
asking for annoying typos (unless you're using TypeScript or Flow, which you
really should consider). See if you can figure out a good way to help people
avoid typos in those strings by perhaps putting all possible action types on an
object somewhere and referencing them instead of hard coding them.

## ü¶â Feedback

Fill out
[the feedback form](https://ws.kcd.im/?ws=Advanced%20React%20Patterns%20%F0%9F%A4%AF&e=05%3A%20State%20Reducer&em=hdessomme%40gmail.com).
